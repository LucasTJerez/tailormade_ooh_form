{"version":3,"sources":["pages/CalculateReach.js","App.js","index.js"],"names":["axios","require","default","CalculateReach","props","state","reachData","reachName","segments","genders","ages","locations","mediums","start","end","backtrackStart","backtrackEnd","comments","formData","sampleReach","names","helperTexts","focusedInput","backtrackFocusedInput","validations","formHasError","fieldHasError","date","backtrack","handleDuration","chosenDate","startDate","endDate","validationsNew","diff","setValidation","setState","handleBacktrack","formDataRaw","formDataNew","key","valid","this","localStorage","getItem","calculatedReaches","setItem","JSON","stringify","audience_api","create","baseURL","timeout","withCredentials","responseType","headers","segmentsNew","locationsNew","segmentsRaw","get","locationsRaw","all","then","spread","responses","data","enumItems","items","map","value","push","displayValue","catch","errors","alert","stringToReturn","Object","keys","forEach","slice","length","field","index","helperTextToSet","fieldHasErrorToSet","error","reachDataLists","Array","isArray","input","includes","validateList","values","window","scrollTo","event","fieldName","target","name","fieldVal","reachDataNew","listCopy","indexOf","splice","validateFails","uploadedReaches","parse","reachDataToUpload","today","Date","dd","String","getDate","padStart","mm","getMonth","yyyy","getFullYear","dateCreated","classes","Grid","container","direction","spacing","item","xs","Collapse","in","Alert","className","severity","AlertTitle","getFieldErrors","FormControl","FormLabel","FormGroup","row","TextField","variant","onChange","handleChange","bind","FormHelperText","Divider","divider","Autocomplete","multiple","id","options","selected","renderTags","getTagProps","option","Chip","label","renderInput","params","placeholder","genderNames","FormControlLabel","control","Checkbox","color","checked","handleSelectChange","light","ageNames","mediumNames","startDateId","endDateId","firstDayOfWeek","displayFormat","onFocusChange","onDatesChange","startDatePlaceholderText","endDatePlaceholderText","isOutsideRange","day","isInclusivelyBeforeDay","moment","component","multiline","Button","buttons","onClick","uploadFormula","size","Component","withStyles","theme","root","flexGrow","marginTop","marginBottom","margin","withTheme","useStyles","makeStyles","backgroundColor","paper","marginLeft","marginRight","calculateReach","padding","App","Paper","Toolbar","Typography","title","noWrap","render","document","querySelector"],"mappings":"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","file":"static/js/main.051ec1c9.chunk.js","sourcesContent":["\nimport React, { Component } from \"react\";\nimport { Autocomplete, Alert, AlertTitle } from '@material-ui/lab';\nimport { DateRangePicker } from 'react-dates';\nimport moment from 'moment';\nimport { withStyles } from \"@material-ui/core/styles\";\nimport { isInclusivelyBeforeDay } from 'react-dates';\nimport {\n    Collapse,\n    FormControl,\n    FormHelperText,\n    Grid,\n    TextField,\n    Checkbox,\n    Chip,\n    FormControlLabel,\n    FormGroup,\n    FormLabel,\n    Button,\n    Divider,\n} from '@material-ui/core';\nimport 'react-dates/initialize';\nimport 'react-dates/lib/css/_datepicker.css';\n\n//used to get market segments from audience api\nconst axios = require('axios').default;\n\n//styles for subcomponents\nconst styles = theme => ({\n    root: { flexGrow: 1, },\n    divider: {\n        marginTop: theme.spacing(2.5),\n        marginBottom: theme.spacing(2.5),\n    },\n    buttons: { margin: \"auto\", },\n    alert: { marginBottom: theme.spacing(2.5) }\n\n})\n\n\nclass CalculateReach extends Component {\n\n    state = {\n        reachData: { //data to upload\n            reachName: \"\",\n            segments: [],\n            genders: [],\n            ages: [],\n            locations: [],\n            mediums: [],\n            start: null,\n            end: null,\n            backtrackStart: null,\n            backtrackEnd: null,\n            comments: \"\",\n        },\n        formData: { //helperData for the form\n            sampleReach: {},\n            names: {},\n            helperTexts: {},\n            segments: [],\n            locations: [],\n            focusedInput: null,\n            backtrackFocusedInput: null,\n        },\n        validations: { //field validation and helper texts\n            formHasError: false,\n            fieldHasError: {\n                reachName: false,\n                locations: false,\n                date: false,\n                mediums: false,\n                ages: false,\n                segments: false,\n                genders: false,\n            },\n            helperTexts: {\n                reachName: \"\",\n                locations: \"\",\n                date: \"\",\n                mediums: \"\",\n                ages: \"\",\n                segments: \"\",\n                comments: \"\",\n                genders: \"\",\n                backtrack: \"\",\n            },\n        },\n    }\n\n    constructor(props) { // instantiates state: formData and validations. formData.segments data uploaded in componentDidMount\n        super(props);\n        const {\n            formData,\n            validations\n        } = this.state;\n\n        let formDataRaw = require('./formData.json');\n        let formDataNew = formData;\n        for (var key in formDataRaw) { // does not instantiate formdata.segments\n            formDataNew[key] = formDataRaw[key]\n        };\n\n        //instantiate helperTexts\n        let validationsNew = validations;\n        validationsNew.helperTexts = formDataNew.helperTexts.valid;\n\n        this.state = { ...this.state, formData: formDataNew, validations: validationsNew, };\n    }\n\n\n\n\n\n    componentDidMount() { //uploads sample reach ato local storage nd instantiates formdata.segments\n        const { formData } = this.state;\n\n        //making sure there are items in local storage, if not, upload an example\n        if (localStorage.getItem(\"calculatedReaches\") === null) {\n            let calculatedReaches = {\n                [formData.sampleReach.reachName]: formData.sampleReach,\n            };\n            localStorage.setItem('calculatedReaches', JSON.stringify(calculatedReaches));\n        };\n\n        //request segments from api\n        const audience_api = axios.create({\n            baseURL: 'https://dev-di-audience-api.apps-dev.tid.es/rest/v1',\n            timeout: 20000,\n            withCredentials: true,\n            responseType: 'json',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': 'Bearer dG1hZHNAdG1hZHM6dWlHekRFd0FoZ0FndGdXWWN0eEFSY21iR2U5RHNIODF6SUZudEUyR0g5czNLNHFIc1V5bHhnVnRraHVCTDVVOVZwRGM3WXBOaFlvSVpLNUc3V2E3T3c'\n            }\n        });\n\n\n        let segmentsNew = [];\n        let locationsNew = [];\n        let segmentsRaw = audience_api.get(\"enum/segments/items\")\n        let locationsRaw = audience_api.get(\"enum/provinces/items\")\n        axios.all([locationsRaw, segmentsRaw]).then(axios.spread((...responses) => {\n            responses[0].data.enumItems.items.map((value) => {\n                locationsNew.push(value.displayValue)\n            })\n            responses[1].data.enumItems.items.map((value) => {\n                segmentsNew.push(value.value)\n            })\n        })).catch(errors => {\n            alert(errors)\n        })\n        this.setState({ formData: { ...formData, segments: segmentsNew, locations: locationsNew } });\n    }\n\n    getFieldErrors() { //returns string of fields with errors for error alert\n        const { fieldHasError } = this.state.validations;\n        let stringToReturn = \"\";\n        Object.keys(fieldHasError).forEach((key) => {\n            if (fieldHasError[key]) {\n                key === \"reachName\" ?\n                    stringToReturn += \"reach name, \"\n                    :\n                    stringToReturn += key + \", \";\n            };\n        });\n        return stringToReturn.slice(0, stringToReturn.length - 2);\n    }\n\n    setValidation(validationsNew, field, index) { //index = -1 means field is valid, index = 0-2 indicates different errors\n        const helperTexts = this.state.formData.helperTexts;\n        let helperTextToSet = \"\";\n        let fieldHasErrorToSet = (index !== -1);\n\n        fieldHasErrorToSet ? helperTextToSet = helperTexts.error[field][index] : helperTextToSet = helperTexts.valid[field];\n\n        validationsNew = {\n            ...validationsNew,\n            fieldHasError: {\n                ...validationsNew.fieldHasError,\n                [field]: fieldHasErrorToSet,\n            },\n            helperTexts: {\n                ...validationsNew.helperTexts,\n                [field]: helperTextToSet,\n            }\n        };\n        return validationsNew;\n    }\n\n    validateList(validationsNew) { // check if lists in reachData are empty\n        let reachDataLists = this.state.reachData;\n\n        Object.keys(reachDataLists).forEach((key) => {\n            if (Array.isArray(reachDataLists[key])) {\n                if (reachDataLists[key].length === 0) {\n                    validationsNew = this.setValidation(validationsNew, key, 0);\n                }\n                else {\n                    validationsNew = this.setValidation(validationsNew, key, -1);\n                };\n            };\n        });\n        return validationsNew;\n    }\n\n    validateFails(input) {\n        const {\n            reachData,\n            validations,\n        } = this.state;\n        const {\n            reachName,\n            start,\n            end,\n        } = reachData;\n        let validationsNew = validations;\n\n\n        //validate reachName\n        if (reachName.length < 4) {\n            validationsNew = this.setValidation(validationsNew, \"reachName\", 0);\n        }\n        else if (reachName.includes(\" \")) {\n            validationsNew = this.setValidation(validationsNew, \"reachName\", 1);\n        }\n        else {\n            validationsNew = this.setValidation(validationsNew, \"reachName\", -1);\n        };\n\n        //validate duration\n        if (start === null || end === null) {\n            validationsNew = this.setValidation(validationsNew, \"date\", 1);\n        };\n\n        //validate reachData lists (segments, genders, ages, locations, mediums)\n        validationsNew = this.validateList(validationsNew);\n\n        let hasError = validationsNew.formHasError = Object.values(validationsNew.fieldHasError).includes(true);\n        if (hasError) { window.scrollTo(0, 0) };\n\n\n        this.setState({ validations: validationsNew });\n    }\n\n    handleChange(event) {\n        let fieldName = event.target.name;\n        let fieldVal = event.target.value;\n        let reachDataNew = this.state.reachData;\n\n        reachDataNew[fieldName] = fieldVal;\n        this.setState({ reachData: reachDataNew });\n    }\n\n    handleSelectChange(event) {\n        let fieldName = event.target.name;\n        let fieldVal = event.target.value;\n        let reachDataNew = this.state.reachData;\n        let listCopy = reachDataNew[fieldName];\n\n        if (listCopy.indexOf(fieldVal) === -1) {\n            listCopy.push(fieldVal);\n        }\n        else {\n            listCopy.splice(listCopy.indexOf(fieldVal), 1);\n        };\n\n        reachDataNew[fieldName] = listCopy;\n\n        this.setState({ reachData: reachDataNew });\n    }\n\n    handleDuration = (chosenDate) => {\n        const {\n            reachData,\n            validations,\n        } = this.state;\n        let {\n            startDate,\n            endDate\n        } = chosenDate;\n        let validationsNew = validations;\n\n        if (startDate && endDate && (endDate.diff(startDate, 'days') > 15)) {\n            validationsNew = this.setValidation(validationsNew, \"date\", 0);\n            endDate = null;\n        }\n        else {\n            validationsNew = this.setValidation(validationsNew, \"date\", -1);\n        };\n        this.setState({ reachData: { ...reachData, start: startDate, end: endDate }, validations: validationsNew });\n    }\n\n    handleBacktrack = (chosenDate) => {\n        const {\n            reachData,\n        } = this.state;\n        let {\n            startDate,\n            endDate\n        } = chosenDate;\n        this.setState({ reachData: { ...reachData, backtrackStart: startDate, backtrackEnd: endDate } });\n    }\n\n\n    uploadFormula() {\n\n        this.validateFails();\n\n        if (!this.state.validations.formHasError) {\n            const uploadedReaches = JSON.parse(localStorage.getItem('calculatedReaches'));\n            const reachDataToUpload = this.state.reachData;\n\n            var today = new Date();\n            var dd = String(today.getDate()).padStart(2, '0');\n            var mm = String(today.getMonth() + 1).padStart(2, '0');\n            var yyyy = today.getFullYear();\n            today = mm + '/' + dd + '/' + yyyy;\n            reachDataToUpload.dateCreated = today\n            \n            uploadedReaches[reachDataToUpload.reachName] = reachDataToUpload;\n            localStorage.setItem('calculatedReaches', JSON.stringify(uploadedReaches));\n        };\n    }\n\n\n\n    render() {\n        const { classes } = this.props;\n        const {\n            reachData,\n            validations,\n            formData,\n        } = this.state;\n        const {\n            mediums,\n            start,\n            end,\n            backtrackStart,\n            backtrackEnd,\n            ages,\n            genders,\n        } = reachData;\n        const {\n            fieldHasError,\n            helperTexts,\n        } = validations;\n\n        return (\n            <Grid\n                container\n                direction=\"column\"\n                spacing={3}\n            >\n                <Grid item xs={12}>\n                    <Collapse in={this.state.validations.formHasError}>\n                        <Alert className={classes.alert} severity=\"error\">\n                            <AlertTitle >Error</AlertTitle>\n                            Fields:\n                            <strong>\n                                {\" \" + this.getFieldErrors()}\n                            </strong>\n                        </Alert>\n                    </Collapse>\n\n                    {/* reachName name */}\n                    <FormControl error={fieldHasError.reachName}>\n                        <FormLabel>Reach Name</FormLabel>\n                        <FormGroup row >\n                            <TextField\n\n                                variant=\"outlined\"\n                                name={\"reachName\"}\n                                onChange={this.handleChange.bind(this)}\n                                error={fieldHasError.reachName}\n                            />\n                        </FormGroup>\n                        <FormHelperText >{helperTexts.reachName}</FormHelperText>\n                    </FormControl>\n\n                    <Divider className={classes.divider} />\n\n                    {/* segments */}\n                    <Autocomplete\n                        multiple\n                        id=\"tags-filled\"\n                        options={formData.segments}\n                        value={reachData.segments}\n                        onChange={(event, selected) => {\n                            this.setState({\n                                reachData: {\n                                    ...reachData,\n                                    segments: selected\n                                }\n                            })\n                        }}\n                        renderTags={(value, getTagProps) =>\n                            value.map((option, index) => (\n                                <Chip label={option} {...getTagProps({ index })} />\n                            ))\n                        }\n                        renderInput={(params) => (\n                            <FormControl error={fieldHasError.segments}>\n                                <FormLabel>Segments</FormLabel>\n                                <TextField error={fieldHasError.segments} {...params} variant=\"outlined\" placeholder=\"Search here\" />\n                                <FormHelperText >{helperTexts.segments}</FormHelperText>\n                            </FormControl>\n                        )}\n                    />\n\n                    <Divider className={classes.divider} />\n\n                    {/* locations */}\n                    <Autocomplete\n                        multiple\n                        id=\"tags-filled\"\n                        options={formData.locations}\n                        // freeSolo //allows any input\n                        value={reachData.locations}\n                        onChange={(event, selected) => {\n                            this.setState({\n                                reachData: {\n                                    ...reachData,\n                                    locations: selected\n                                }\n                            })\n                        }}\n                        renderTags={(value, getTagProps) =>\n                            value.map((option, index) => (\n                                <Chip label={option} {...getTagProps({ index })} />\n                            ))\n                        }\n                        renderInput={(params) => (\n                            <FormControl error={fieldHasError.locations}>\n                                <FormLabel>Locations</FormLabel>\n                                <TextField error={fieldHasError.locations} {...params} variant=\"outlined\" placeholder=\"Search here\" />\n                                <FormHelperText >{helperTexts.locations}</FormHelperText>\n                            </FormControl>\n                        )}\n                    />\n\n                    <Divider className={classes.divider} />\n\n                    {/* genders */}\n                    <FormControl error={fieldHasError.genders}>\n                        <FormLabel>Genders</FormLabel>\n                        <FormGroup row>\n                            {formData.names.genderNames.map((name) => (\n                                <FormControlLabel\n                                    key={name}\n                                    control={\n                                        <Checkbox\n                                            color=\"primary\"\n                                            checked={genders.indexOf(name) > -1}\n                                            name={\"genders\"}\n                                            value={name}\n                                            onChange={this.handleSelectChange.bind(this)}\n                                        />\n                                    }\n                                    label={name}\n                                />\n                            ))}\n                        </FormGroup>\n                        <FormHelperText>{helperTexts.genders}</FormHelperText>\n                    </FormControl>\n\n                    <Divider light className={classes.divider} />\n\n                    {/* age */}\n                    <FormControl error={fieldHasError.ages}>\n                        <FormLabel>Ages</FormLabel>\n                        <FormGroup row>\n                            {formData.names.ageNames.map((name) => (\n                                <FormControlLabel\n                                    key={name}\n                                    control={\n                                        <Checkbox\n                                            name={\"ages\"}\n                                            value={name}\n                                            onChange={this.handleSelectChange.bind(this)}\n                                            color=\"primary\"\n                                            checked={ages.indexOf(name) > -1}\n                                        />\n                                    }\n                                    label={name}\n                                />\n                            ))}\n                        </FormGroup>\n                        <FormHelperText>{helperTexts.ages}</FormHelperText>\n                    </FormControl>\n\n                    <Divider className={classes.divider} />\n\n                    {/* medium */}\n                    <FormControl error={fieldHasError.mediums}>\n                        <FormLabel>Mediums</FormLabel>\n                        <FormGroup row>\n                            {formData.names.mediumNames.map((name) => (\n                                <FormControlLabel\n                                    key={name}\n                                    control={\n                                        <Checkbox\n                                            color=\"primary\"\n                                            checked={mediums.indexOf(name) > -1}\n                                            name={\"mediums\"}\n                                            value={name}\n                                            onChange={this.handleSelectChange.bind(this)}\n                                        />\n                                    }\n                                    label={name}\n                                />\n                            ))}\n\n                        </FormGroup>\n                        <FormHelperText>{helperTexts.mediums}</FormHelperText>\n                    </FormControl>\n\n                    <Divider light className={classes.divider} />\n\n                    {/* DATE RANGE PICKER */}\n                    <FormControl error={fieldHasError.date}>\n                        <FormLabel>Duration</FormLabel>\n                        <FormGroup row>\n                            <DateRangePicker\n                                startDateId=\"durationStart\"\n                                endDateId=\"durationEnd\"\n                                firstDayOfWeek={1}\n                                startDate={start}\n                                endDate={end}\n                                displayFormat=\"DD-MM-YYYY\"\n                                focusedInput={formData.focusedInput}\n                                onFocusChange={focusedInput =>\n                                    this.setState({ formData: { ...formData, focusedInput } })\n                                }\n                                onDatesChange={this.handleDuration}\n                                startDatePlaceholderText=\" Start date\"\n                                endDatePlaceholderText=\" End date\"\n                            />\n                        </FormGroup>\n                        <FormHelperText>{helperTexts.date}</FormHelperText>\n                    </FormControl>\n\n                    <Divider className={classes.divider} />\n\n                    {/* backtrack */}\n                    <FormControl error={validations.backtrack}>\n                        <FormLabel>Backtrack Data</FormLabel>\n                        <FormGroup row>\n                            <DateRangePicker\n                                startDateId=\"backtrackStart\"\n                                endDateId=\"backtrackEnd\"\n                                isOutsideRange={day => !isInclusivelyBeforeDay(day, moment())}\n                                firstDayOfWeek={1}\n                                startDate={backtrackStart}\n                                endDate={backtrackEnd}\n                                displayFormat=\"DD-MM-YYYY\"\n                                focusedInput={formData.backtrackFocusedInput}\n                                onFocusChange={backtrackFocusedInput =>\n                                    this.setState({ formData: { ...formData, backtrackFocusedInput } })\n                                }\n                                onDatesChange={this.handleBacktrack}\n                                startDatePlaceholderText=\" Start date\"\n                                endDatePlaceholderText=\" End date\"\n                            />\n                        </FormGroup>\n                        <FormHelperText>*optional: use data from a period of time</FormHelperText>\n                    </FormControl>\n\n                    <Divider className={classes.divider} />\n\n\n                    {/* comments */}\n                    <FormControl >\n                        <FormGroup component=\"legend\">\n                            <FormLabel >Comments</FormLabel>\n                            <TextField\n                                name={\"comments\"}\n                                onChange={this.handleChange.bind(this)}\n                                color=\"primary\"\n                                multiline\n                                variant=\"outlined\"\n                            />\n\n                        </FormGroup>\n                        <FormHelperText>{helperTexts.comments}</FormHelperText>\n                    </FormControl>\n                </Grid >\n\n                <Button\n                    className={classes.buttons}\n                    onClick={() => this.uploadFormula()}\n                    variant=\"contained\"\n                    size=\"large\"\n                    color=\"primary\"\n                >\n                    Submit\n                    </Button>\n            </Grid >\n        );\n    }\n}\n\n\n\nexport default withStyles(styles, { withTheme: true })(CalculateReach);","import React from \"react\";\nimport { makeStyles } from '@material-ui/core/styles';\nimport { Typography, Toolbar, Paper } from '@material-ui/core';\n\nimport CalculateReach from \"./pages/CalculateReach\";\n\nconst useStyles = makeStyles((theme) => ({\n    root: {\n        flexGrow: 1,\n        backgroundColor: '#757ce8',\n    },\n    paper: {\n        marginLeft: theme.spacing(8),\n        marginRight: theme.spacing(8),\n    },\n    calculateReach: {\n        padding: theme.spacing(4),\n    },\n}));\n\n\n\nexport default function App() {\n    const classes = useStyles();\n    return (\n        <div className={classes.root} >\n\n\n            <Paper className={classes.paper}>\n\n                    <Toolbar>\n                        <Typography color=\"textSecondary\" className={classes.title} variant=\"h4\" noWrap>\n                            Out-of-Home Reach Request Form\n          </Typography>\n                    </Toolbar>\n                <div className={classes.calculateReach}>\n                    <CalculateReach />\n                </div>\n            </Paper>\n        </div>\n    );\n}\n\n\n","import \"bootstrap/dist/css/bootstrap.min.css\";\nimport React from 'react';\nimport { render } from 'react-snapshot';\nimport \"./index.css\";\nimport App from \"./App\";\n\n\n\n\nrender(<App />, document.querySelector('#root'));\n"],"sourceRoot":""}